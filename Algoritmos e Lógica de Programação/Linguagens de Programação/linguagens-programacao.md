# Linguagens de Programação

As linguagens de programaçãoeram separadas para fins ditáticos, em "gerações". Atualmente, esse tipo de classificação perdeu o sentido, mas para efeito histórico relativo e para conhecermos a história das linguagens de programação, parece bastante adequado usarmos (ainda) esse antigo conceito.

### Primeira Geração

As linguagens de primeira geração (Assembly) (ou 1GL) referem-se ao código de máquina. É a única linguagem que um microprocessador pode entender nativamente. O código de máquina não pode ser escrito ou lido por um editor de texto, e, portanto, é raramente usado por uma pessoa diretamente. Foi usada apenas na programação dos primeiros computadores criados. Naturalmente, era totalmente dependente do processador do computador para o qual se escrevia o programa.

### Segunda Geração

A linguagem de segunda geração (ou 2GL) é a linguagem Assembler. É considerada de segunda geração, pois embora não seja uma linguagem nativa do microprocessador, um programador que use a linguagem Assembler ainda deve compreender as características da arquitetura do microprocessador (como registradores e instruções).

Há muitas controvérsias quanto a essa classificação, pois muitos autores entendem que Assembler e Assembly fazem parte de uma mesma geração de linguagens de programação. Fazendo essa ressalva, vamos utilizar essa nomenclatura para nos referir ao Assembly (1GL) e o Assembler (2GL).

### Terceira Geração

Também há controvérsias quanto ao que seria a primeira geração de linguagens de alto nível (3GL em nossa classificação). Alguns autores entendem que FORTRAN, COBOL e ALGOL seriam de uma geração, enquanto Pascal e C seriam de uma geração posterior, em nome de uma maior estruturação dessas linguagens. Novamente ficaremos com os autores que entendem ser de terceira geração as linguagens de alto nível escritas em derivações da língua inglesa, restritas a criação de programas na própria linguagem de programação. Assim, todas as linguagens citadas seriam de terceira geração, embora o tempo de criação entre as mesmas tenha sido substancialmente grande, como veremos mais adiante.

Embora o FORTRAN tenha sido a primeira linguagem de teceira geração a ser usada, a primeira linguagem criada não foi esta. Criada em 1946, nomeada Plankalkül por Konrad Zuse, engenheiro alemão, esta teriado sido a primeira linguagem criada de alto nível. A polêmica existente resulta da publicação do trabalho de Zuse apenas em 1972.

Zuse queria desenvolver um método sofisticado para o desenvolvimento das tarefas que a equipe deve fazer. Não existem programas criados para essa linguagem de computador. Sua máquina computadora S2 é considerada o primeiro computador controlado por processamento (e não o Mark I, como se popularmente diz), o qual foi usado para ajudar a desenvolver os mísseis Henschel Hs 293 E Henschel Hs 294, percursores dos modernos mísseis de cruzeiro.

Feita essa ressalva, considera-se que a primeira linguagem de alto nível foi criada em 1954 pelo norte-americano John Backus, da IBM, que a denominou FORTRAN (Formula Translation).

Pouco tempo depois, precisamente em 1958, surgem o ALGOL - origem da maioria das linguagens modernas, e o LISP, criada por John MacCarthy, norte-americano, no MIT.

Em 1959, surge o COBOL, com uma série de melhorias na entrada e saída de dados. Criado por uma equipe de programadores, esta é a linguagem mais antiga em uso. Foi concebida a partir dos esforços pioneiros da norte-americana, Grace Murray Hopper, que foi analista de sistemas da Marinha dos Estados Unidos nas décadas de 1940 e 1950, chegando à patente de Almirante.

Foi ela quem criou a linguagem de programação Flow-Matic, que serviu como base para a criação do COBOL. Por isso, é considerada a "autora" do do COBOL. Dentre outras realizações da Almirante, está a criação do primeiro compilador, e COBOL, sendo a primeira linguagem de programação de computadores a se aproximar da linguagem humana ao invés da linguagem de máquina. Tanto FORTRAN, como ALGOL e LISP, eram mais próximas de uma linguagem de máquina do que da linaguagem humana. De fato, COBOL utiliza palavras da língua inglesa, mas busca uma maior proximidade com a construção humana das frases do que com algoritmos.

A almirante Hooper ficou conhecida popularmente como "a velha do COBOL", todavia ela não participou efetivamente na criação da linguagem COBOL, mas sim de um subcomitê proposto numa reunião no Pentagono em maio de 1959.

Este subcomitê desenvolveu as especificações da linguagem COBOL. Ele era formado por: William Selden, Gertrude Tierney da IBM; Howard Bromberg e Howard Discount da RCA; Vernon Reeves e Jean E. Sammet da Sylvania Electric Products.

A concepção de Hopper é de que havia a necessidade de se criar uma linguagem orientada para negócios comuns, desde então, deu origem ao acrônimo COBOL (**CO**mmon **B**usiness **O**riented **L**anguage).Tudo foi feito sem definir os comandos para minimizar melindres entre os técnicos das empresas convocadas a participar da criação de um denominador comum entre todos os fabricantes existentes na época.

Grance Hopper participou contribuindo com a abertura dos comandos FLOW-MATIC.

Posteriormente, em 1964, surge o BASIC - Beginners All-purpose Symbolic Instruction Code, que foi criado originalmente para ensiono, mas acabou por se tornar um dos padrões de desenvolvimento.

Bill Gates (primeiro à esquerda na foto histórica com os fundados da Microsoft) ganhou um prêmio com a versão que criou (MBASIC, sendo o M de Microsoft, inda sem o indefctível "S") e que teve sua versão de maior sucesso criada em 1991.

Em 1967, surge o Simula 67, que introduz os conceitos de orientação a objetos, que muitos anos depois se tornaria o padrão a ser seguido por quase todas as linguagens de programação.

Pouco depois, em 1970, surge o Pascal, criado pelo húngaro Niklçaus Wirth, que ganharia enorme popularidade na década de 1980, a partir da implementação do Turbo Pascal, pela Borland.

Em 1973, surge a linguagem C, aproveitando a linguagem "BCPL", criado por Dnies Ritchie, da AT&T.

### Quarta Geração e Post

São linguagens de programação que podem criar programas em outras linguagens, quesão voltadas a pesquisas, ou que por meio de interfaces permitem a criação de códigos sem a digitação efetiva de comandos. Atualmente, faz pouco sentido buscar compreender hardware e software pelo conceito de geração, dadas as especificidades e intercorrências entre as influências sofridas e/ou causadas por determinada aplicação. Assim, a partir da 4ª geração de linguagens, não parece fazer muito sentido classificar tecnologias por geração.

São especialmente notáveis algumas situções, que passamos a enumerar:

**Linguagens de interface com banco de dados:** surgiram com o intuito de acessar algum banco de dados, habitualmente baseados no modelo relacional. Durante algum tempo contaram com mais usuários que as tradicionais linguagens de programação (COBOL, C, Pascal e BASIC). No entanto, foi um fenômeno passageiro, que teve início em meados da década de 1980 e tendo sido encerrado antes do final da década de 1990. O maior destaque foi da Nantucket Clipper, mas Data Ease, Data Flex, FoxPro, FORMS estão entre várias outras linguagens de acesso de forma proprietária a banco de dados.

**Linguagens orientadas a objetos**: destacam-se o Java, C#, Visual BASIC e Delphi. Atualmente, Java e C# dominam amplamente o mercado de desenvolvimento de software.

## Introdução à Lógica de Programação

Quando observamos a palavra "algoritmo", parece soar um pouco estanho aos nossos ouvidos, que são muito mais familiarizadas com palavras de origens latinas do que árabes, o que é o caso de "algoritmo". Essa palavra deriva de Al-Khwarizmi, matemático persa do século IX, a quem se atribui a construção dos primeiros processos para realização de operações aritméticas, o que explica o porquê do nome de um matemático ter sido associado a um processo repetitivo que leva à solução de problemas complexos.

***Algoritmo, por definição, é uma sequência de instruções ordenada com o objetivo de resolver um problema.***

Por volta do século 3 a.C., outro matemático famoso, o grego Euclides, escreve seu famoso algoritmo para o cálculo do MDC (Máximo Divisor Comum). É, provavelmente, o primeiro algoritmo complexo e formalizado de que se tem notícia.

### ALGORITMOS X PROGRAMAS DE COMPUTADOR

Confunde-se frequentemente algoritmo e programa de computador, o que não tem razão de ser. Simplesmente, usamos de um computador para executar um algoritmo. Isso se deve ao fato do computador ser mais rápido e preciso que um ser humano (Máquina Oligofrênica).

No entanto, primeiramente, o algoritmo deve ser transcrito para uma linguagen de programação qualquer, antes de podermos "usá-lo" num computador.

Em seguida, esse código escrito numa linguagem de programação (o "programa") deve ser transformado num programa executável num computador, portanto esse programa deverá ser compilado (processo de validação de sintaxe utilizada) e linkeditado (processo de montagem do programa executável).

Serão apresentadas breves noções de fluxograma, observando-se que sua pouca serventia em programas mais complexos, "causando mais mal do que bem" (GANE, 1983, p. 4).

### Conceituação de Algoritmos

Todo programa deveria ter um ciclo de desenvolvimento aproximado à lista:

* Análise do Problema.

* Projeto do Programa.

* Implementação.

* Testes.

* Verificação.

### Análise - Compreensão

Antes de partirmos para a solução de um problema, devemos entendê-lo o melhor possível.

Ao nos depararmos com um problema, o primeiro passo é compreendê-lo inteiramente. Lembre-se de que quem está perdido e pôem-se a andar, tende a ser perder ainda mais.

Assim, é uma boa estratégia perguntar:

* O que devemos descobrir, calcular ou obter? Qual é o objetivo do programa?

* Quais são os dados disponíveis? São suficientes para atendermos o que se quer?

* Quais são as condições necessárias e suficientes para resolver o problema?

É importante desenhar, rascunhar e usar de todos os artifícios para montar a "lógica" que nos leve à solução ou menos a um racicionio intermediário.

A 1ª Etapa - Análise do Problema - consiste então na compreensão do problema e montgem de uma estratégia para sua resolução.

Você deve se lembrar, antes de qualquer outra coisa, que um algoritmo nada mais é que uma forma de representar a lógica que desejeamos aplicaar. Assim, antes de construir um algoritmo, precisamos definir alguma estratégia.

### Análise - Estratégia

Criar uma estratégia para a solução, passa pela resposta a algumas perguntas, um tanto elementares:

* Já resolveu algum problema similar? Qual?

Se sim, a solução pode ser aproveitada por analogia, para referência ou por ser parte da solução do novo problema. Observe se será necessário introduzir elementos novos ou modificar os existentes.

Já se o problema for muito complexo, provavelmente pode ser fracionado em partes menores, de solução mais simples.

* É possível enxergar o problema de outra forma, de modo que o entendimento se torne mais simples?

Lembre-se que descer uma escada de costas é bem mais complicado do que da maneira natural e chegamos sempre ao mesmo lugar.

Obtidas as respostas, não tente criar a solução inteira, antes de rascunhá-la!

Siga os passos:

* Crie um algoritmo informal com as instruções que resolvam o problema ou que ao menos pareçam resolvê-lo.

* Verifique se cada passo desse algoritmo está correto, simulando-o num papel (teste de mesa ou simulação).

* Identifique os erros e os trate um por vez, sem nunca perder de vista o objetivo real do programa. Esse processo ordenado logicamente faz você aprender a desenvolver soluções.

Quando se elabora um esboço da solução do problema, para em seguida ir-se refinando essa solução, até chegar=se a uma sequência básica de operações que resolva o problema, usou-se uma das principais técnicas relacionadas à construção de algoritmos, intitulada Top-Down.

Essa técnica leva à geração de um pseudocódigo, que chamaremos de Português Estruturado (evite-se a expressão portugol).

O Português Estruturado, na opinião da maioria dos autores de livros de análise, programação ou algoritmos é muito mais eficaz que fluxogramas (estes são muito mais úteis em administração, que não é nosso caso.)

### Projeto de Programa

Este nada mais é que o algoritmo gerado, que visará otimizar o "o binômio tempo-espaço, isto é, visando obter um programa que apresente um tempo de execução mínimo e com o melhor aproveitamento de espaço de memória" (SALVETTI; BARBOSA, 1998).

**a) Implementação**

Quando codificamos um algoritmo numa linguagem de programação, o estamos implementando.

Você poderá, quando estiver cusando disciplinas de Linguagem de Programação, transformar todos os algoritmos vistos em nosso curso em programas de computador.

A implementação pode ser trivial, com a mera substituição de instruções algorítmicas em instruções em uma linguagem ou muito trabalhosa, dependendo da linguagem escolhida.

**b) Testes**

A fase de testes vem crescentemente sendo valorizada. Devemos lembrar que quem faz o programa, rarmente testa seus pontos deficientes. Ora, isso ocorre porque se o analista tivesse percebido essas deficiências, provavelmente o programa não apresentaria esses problemas. Há varias técnicas para testes (caixa, branca, caixa preta, entre várias outras).

Negligenciar essa fase é fatal. Numa prova, nem pensar.

**c) Verificação do programa**

A verificação do programa visa demonstrar que o algoritmo realmente resolve o problema proposto, qualquer que seja sua instância.

É nesta etapa que se constata se o programa resolve todos os casos possíveis! Constata-mos a sabedoria do velho provérbio inglês que diz "que todo problema complexo, aparentemente tem uma solução simples, que usualmente está errada [...]".

Ao simularmos nossos algoritmos estamos fazendo exatamente esse processo. Todavia, quando codificado numa linguagem, mesmo que o algoritmo tenha sido simulado à exaustõ, continuaremos obrigados a testar o programa que foi implementado.